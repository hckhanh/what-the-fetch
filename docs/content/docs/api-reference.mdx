---
title: API Reference
description: Complete API documentation for what-the-fetch with detailed examples and type signatures
---

## Main Function

### `createFetch()`

Creates a type-safe fetch function for your API.

```typescript
function createFetch<Schema extends ApiSchema>(
  apis: Schema,
  baseUrl: string
): <Path extends ApiPath<Schema>>(
  path: Path,
  options: FetchOptions<Schema, Path>,
  baseInit?: RequestInit
) => Promise<ApiResponse<Schema, Path>>
```

**Parameters:**

- `apis` - An object mapping API paths to their schema definitions
- `baseUrl` - The base URL for all API requests

**Returns:** A typed fetch function that accepts:
- `path` - The API path (must be a key from your schema)
- `options` - Request options (params, query, body) based on the path's schema
- `baseInit` - Optional RequestInit to customize the fetch request

**Example:**

```typescript
import { createFetch } from 'what-the-fetch';
import { z } from 'zod';

const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    query: z.object({ fields: z.string().optional() }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const user = await apiFetch('/users/:id', {
  params: { id: 123 },
  query: { fields: 'name,email' }
});
// user is typed as { id: number; name: string; email: string }
```

---

## Type Definitions

### `ApiSchema`

Schema definition for an API. Maps API paths to their schema definitions.

```typescript
type ApiSchema = Record<
  string,
  {
    params?: StandardSchemaV1<Record<string, unknown>, unknown>
    query?: StandardSchemaV1<Record<string, unknown>, unknown>
    body?: StandardSchemaV1<Record<string, unknown>, unknown>
    response?: StandardSchemaV1<Record<string, unknown>, unknown>
  }
>
```

Each path in your schema can have:

- `params` - Schema for URL path parameters (e.g., `:id`)
- `query` - Schema for query string parameters
- `body` - Schema for request body (automatically sets method to POST)
- `response` - Schema for response validation

**Example:**

```typescript
import { z } from 'zod';

const api: ApiSchema = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    query: z.object({ fields: z.string().optional() }),
    response: z.object({ id: z.number(), name: z.string() })
  },
  '/users': {
    // GET /users - List users with pagination
    query: z.object({
      limit: z.number().optional(),
      offset: z.number().optional()
    }),
    response: z.array(z.object({ id: z.number(), name: z.string() }))
  }
};
```

### `ApiPath<T>`

Extract valid API paths from an API schema.

```typescript
type ApiPath<T extends ApiSchema> = keyof T & string
```

**Example:**

```typescript
const api = {
  '/users/:id': { /* ... */ },
  '/posts': { /* ... */ }
};

type Path = ApiPath<typeof api>;
// Path = '/users/:id' | '/posts'
```

### `FetchOptions<T, Path>`

Extract the required fetch options for a specific API path.

```typescript
type FetchOptions<T extends ApiSchema, Path extends ApiPath<T>> = 
  // Infers correct types for params, query, and body
```

Automatically infers the correct types for params, query, and body based on the schema definition for the given path.

**Example:**

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    query: z.object({ fields: z.string().optional() })
  }
};

type Options = FetchOptions<typeof api, '/users/:id'>;
// Options = { params: { id: number }, query?: { fields?: string } }
```

### `ApiResponse<T, Path>`

Extract the response type for a specific API path.

```typescript
type ApiResponse<T extends ApiSchema, Path extends ApiPath<T>> =
  // Infers response type from schema
```

Infers the correct return type based on the response schema definition.

**Example:**

```typescript
const api = {
  '/users/:id': {
    response: z.object({ id: z.number(), name: z.string() })
  }
};

type Response = ApiResponse<typeof api, '/users/:id'>;
// Response = { id: number; name: string }
```

---

## Request Examples

### GET Request with Path Parameters

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const user = await apiFetch('/users/:id', {
  params: { id: 123 }
});
// GET https://api.example.com/users/123
```

### GET Request with Query Parameters

```typescript
const api = {
  '/users': {
    query: z.object({
      limit: z.number().optional(),
      offset: z.number().optional(),
      sort: z.string().optional()
    }),
    response: z.array(z.object({
      id: z.number(),
      name: z.string()
    }))
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const users = await apiFetch('/users', {
  query: { limit: 10, offset: 0, sort: 'name' }
});
// GET https://api.example.com/users?limit=10&offset=0&sort=name
```

### GET Request with Both Path and Query Parameters

```typescript
const api = {
  '/users/:id/posts': {
    params: z.object({ id: z.number() }),
    query: z.object({
      limit: z.number().optional(),
      published: z.boolean().optional()
    }),
    response: z.array(z.object({
      id: z.number(),
      title: z.string()
    }))
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const posts = await apiFetch('/users/:id/posts', {
  params: { id: 123 },
  query: { limit: 10, published: true }
});
// GET https://api.example.com/users/123/posts?limit=10&published=true
```

### POST Request with Body

```typescript
const api = {
  '/users': {
    body: z.object({
      name: z.string(),
      email: z.string().email()
    }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const newUser = await apiFetch('/users', {
  body: {
    name: 'John Doe',
    email: 'john@example.com'
  }
});
// POST https://api.example.com/users
// Content-Type: application/json
// Body: {"name":"John Doe","email":"john@example.com"}
```

### Custom Headers and Options

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({ id: z.number(), name: z.string() })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const user = await apiFetch(
  '/users/:id',
  { params: { id: 123 } },
  {
    headers: {
      'Authorization': 'Bearer token',
      'X-Custom-Header': 'value'
    },
    cache: 'no-cache',
    signal: abortController.signal
  }
);
```

---

## Advanced Usage

### Multiple Endpoints with Shared Schemas

```typescript
import { createFetch } from 'what-the-fetch';
import { z } from 'zod';

// Define reusable schemas
const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string()
});

const PostSchema = z.object({
  id: z.number(),
  title: z.string(),
  content: z.string(),
  authorId: z.number()
});

// Use schemas in multiple endpoints
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: UserSchema
  },
  '/users': {
    response: z.array(UserSchema)
  },
  '/posts/:id': {
    params: z.object({ id: z.number() }),
    response: PostSchema
  },
  '/users/:id/posts': {
    params: z.object({ id: z.number() }),
    response: z.array(PostSchema)
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');
```

### Building a Complete API Client

```typescript
import { createFetch } from 'what-the-fetch';
import { z } from 'zod';

// Define comprehensive API schema
const api = {
  '/users': {
    // GET /users - List users with pagination
    query: z.object({
      page: z.number().optional(),
      limit: z.number().optional()
    }),
    response: z.object({
      users: z.array(z.object({
        id: z.number(),
        name: z.string()
      })),
      total: z.number()
    })
  },
  '/users/:id': {
    // GET /users/:id - Get user by ID
    params: z.object({ id: z.number() }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string(),
      createdAt: z.string()
    })
  },
  '/users/create': {
    // POST /users/create - Create new user
    body: z.object({
      name: z.string().min(3),
      email: z.string().email(),
      password: z.string().min(8)
    }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  },
  '/users/:id/update': {
    // PATCH /users/:id/update - Update user
    params: z.object({ id: z.number() }),
    body: z.object({
      name: z.string().min(3).optional(),
      email: z.string().email().optional()
    }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
} as const;

// Create client
class APIClient {
  private fetch;

  constructor(baseUrl: string, apiKey: string) {
    this.fetch = createFetch(api, baseUrl);
    this.apiKey = apiKey;
  }

  async getUsers(page = 1, limit = 10) {
    return this.fetch(
      '/users',
      { query: { page, limit } },
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
  }

  async getUser(id: number) {
    return this.fetch(
      '/users/:id',
      { params: { id } },
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
  }

  async createUser(data: { name: string; email: string; password: string }) {
    return this.fetch(
      '/users/create',
      { body: data },
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
  }

  async updateUser(id: number, data: { name?: string; email?: string }) {
    return this.fetch(
      '/users/:id/update',
      { params: { id }, body: data },
      { headers: { 'Authorization': `Bearer ${this.apiKey}` } }
    );
  }
}

// Usage
const client = new APIClient('https://api.example.com', 'your-api-key');
const users = await client.getUsers(1, 20);
const user = await client.getUser(123);
```

---

## Standard Schema Support

what-the-fetch works with any schema library that implements [Standard Schema](https://standardschema.dev/):

### Zod

```typescript
import { z } from 'zod';

const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({ id: z.number(), name: z.string() })
  }
};
```

### Valibot

```typescript
import * as v from 'valibot';

const api = {
  '/users/:id': {
    params: v.object({ id: v.number() }),
    response: v.object({ id: v.number(), name: v.string() })
  }
};
```

### ArkType

```typescript
import { type } from 'arktype';

const api = {
  '/users/:id': {
    params: type({ id: 'number' }),
    response: type({ id: 'number', name: 'string' })
  }
};
```

---

## Error Handling

### HTTP Errors

what-the-fetch automatically throws an error for non-2xx status codes:

```typescript
try {
  const user = await apiFetch('/users/:id', { params: { id: 999 } });
} catch (error) {
  console.error('HTTP error:', error.message);
  // → "HTTP error! status: 404"
}
```

### Validation Errors

Schema validation errors are thrown when response doesn't match the schema:

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({
      id: z.number(),
      name: z.string() // Required field
    })
  }
};

try {
  // If server returns { id: 123 } without name field
  const user = await apiFetch('/users/:id', { params: { id: 123 } });
} catch (error) {
  console.error('Validation error:', error);
  // Schema validation failed
}
```

---

## TypeScript Features

### Full Type Inference

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({ id: z.number(), name: z.string() })
  }
} as const;

const apiFetch = createFetch(api, 'https://api.example.com');

// TypeScript infers everything:
const user = await apiFetch('/users/:id', {
  params: { id: 123 } // TypeScript knows params is required and id must be number
});
// TypeScript knows user is { id: number; name: string }
```

### Autocomplete Support

When using what-the-fetch in TypeScript, you get full autocomplete for:

- Available API paths
- Required options (params, query, body)
- Field names and types
- Response properties

### Compile-Time Validation

```typescript
// ✅ This compiles
await apiFetch('/users/:id', { params: { id: 123 } });

// ❌ TypeScript error: Property 'params' is missing
await apiFetch('/users/:id', {});

// ❌ TypeScript error: Type 'string' is not assignable to type 'number'
await apiFetch('/users/:id', { params: { id: '123' } });

// ❌ TypeScript error: '/invalid' is not assignable to type '/users/:id' | ...
await apiFetch('/invalid', {});
```

---

## Performance Considerations

what-the-fetch is designed to be performant:

- **Small bundle size**: Minimal dependencies (only fast-url for URL building and Standard Schema spec)
- **Efficient URL building**: Leverages fast-url library's optimized implementation
- **Type-level computation**: Most type checking happens at compile time
- **Runtime validation**: Only validates responses, not TypeScript types

### Bundle Size

what-the-fetch adds minimal overhead to your bundle:

- Core library: ~2KB minified + gzipped
- Plus your choice of schema library (Zod, Valibot, etc.)

---

## Browser and Runtime Compatibility

what-the-fetch works in all modern JavaScript environments:

- ✅ Node.js 18+
- ✅ Bun
- ✅ Deno
- ✅ Modern browsers (Chrome, Firefox, Safari, Edge)
- ✅ React Native
- ✅ Electron

**Requirements:**

- `fetch` API support (built-in in modern environments)
- Standard Schema-compatible validation library
