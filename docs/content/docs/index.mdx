---
title: Introduction
description: Learn about afetch ‚Äì a type-safe API client with schema validation using Standard Schema
---

import { Feather, ShieldCheck, Lock, Code, Wrench, Zap } from 'lucide-react';

**afetch** is a type-safe API client library that integrates schema validation with fetch requests, leveraging the Standard Schema specification for maximum flexibility and type safety.

<Callout title="Why afetch?" type="info">
  Building API clients manually is error-prone and lacks type safety. afetch
  handles type-safe URL construction, automatic request/response validation,
  and full TypeScript inference automatically.
</Callout>

## Why afetch?

Building API clients manually is tedious and error-prone. afetch solves common problems developers face when working with APIs:

### Problems with Manual API Clients

- **üî¥ No type safety**: Response types are unknown, leading to runtime errors
- **üî¥ Manual validation**: You need to write validation code for every endpoint
- **üî¥ Schema duplication**: Types and validation logic are often duplicated
- **üî¥ URL building errors**: String concatenation leads to malformed URLs
- **üî¥ Poor developer experience**: No autocomplete, no compile-time checks

### How afetch Solves These Issues

**afetch** provides a complete solution for type-safe API clients:

1. **End-to-end type safety**:

   - Full TypeScript inference from schema to response
   - Compile-time validation of requests
   - Autocomplete for all API endpoints and parameters
   - Type-safe path and query parameters

2. **Schema validation**:

   - Built-in support for Standard Schema specification
   - Works with Zod, Valibot, ArkType, and more
   - Automatic request/response validation
   - Single source of truth for types and validation

3. **Clean API**:

   - Simple, intuitive interface
   - Integrated with fast-url library for clean URL construction
   - Minimal boilerplate code
   - Focus on developer experience

4. **Production-ready**:
   - Comprehensive test coverage
   - Small bundle size
   - Battle-tested in real-world applications
   - Regular updates and maintenance

## Key Features

<Cards>
  <Card title="Type-Safe" icon={<ShieldCheck />}>
    Full TypeScript support with end-to-end type inference from schema
    definition to response data
  </Card>
  <Card title="Schema Validation" icon={<Lock />}>
    Built-in support for Standard Schema - compatible with Zod, Valibot,
    ArkType, and more
  </Card>
  <Card title="Flexible" icon={<Wrench />}>
    Works with any schema library that implements Standard Schema for maximum
    flexibility
  </Card>
  <Card title="Minimal" icon={<Feather />}>
    Small bundle size with minimal dependencies - only fast-url library and
    Standard Schema spec
  </Card>
  <Card title="URL Building" icon={<Code />}>
    Integrated with fast-url library for clean, safe URL construction with
    path and query parameters
  </Card>
  <Card title="Developer Experience" icon={<Zap />}>
    Excellent developer experience with full autocomplete and compile-time error
    checking
  </Card>
</Cards>

## The Problem

Building API clients manually lacks type safety and validation:

```typescript
// ‚ùå No type safety, manual validation
const response = await fetch(`${baseUrl}/users/${id}?fields=${fields}`);
const data = await response.json();
// What type is data? Who knows! Runtime errors waiting to happen
```

**Issues with manual API clients:**

- üî¥ No type safety for request parameters
- üî¥ Unknown response types
- üî¥ Manual validation required
- üî¥ Schema and types are duplicated
- üî¥ Difficult to maintain and refactor

## The Solution

afetch provides a type-safe API client with automatic validation:

```typescript
// ‚úÖ Type-safe with validation
import { createFetch } from 'afetch';
import { z } from 'zod';

const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    query: z.object({ fields: z.string().optional() }),
    response: z.object({ id: z.number(), name: z.string(), email: z.string() })
  }
};

const apiFetch = createFetch(api, baseUrl);
const user = await apiFetch('/users/:id', {
  params: { id },
  query: { fields }
});
// user is fully typed as { id: number; name: string; email: string }
```

**Benefits:**

- ‚úÖ Full end-to-end type safety
- ‚úÖ Automatic request/response validation
- ‚úÖ Single source of truth for types and validation
- ‚úÖ Clean separation of concerns
- ‚úÖ Easy to read and maintain

<Callout title="Type Safety & Validation" type="success">
  afetch handles type-safe URL construction, automatic validation, and full
  TypeScript inference - catching errors at compile time instead of runtime.
</Callout>



## When to Use afetch

afetch is ideal for:

- üåê **REST API clients**: Building type-safe wrappers around REST APIs
- üîó **Microservices**: Creating typed clients for service-to-service communication
- üì± **Frontend applications**: Type-safe data fetching with validation
- üõ†Ô∏è **Backend services**: Calling external APIs with full type safety
- üìä **SDK development**: Building SDKs with excellent developer experience

## Quick Example

Here's a real-world example showing how afetch simplifies API client development:

<Tabs items={['With afetch', 'Without afetch']}>
  <Tab value="With afetch">
    ```typescript
    import { createFetch } from 'afetch';
    import { z } from 'zod';
    
    // Define API schema once
    const api = {
      '/users/:id': {
        params: z.object({ id: z.number() }),
        query: z.object({ fields: z.string().optional() }),
        response: z.object({
          id: z.number(),
          name: z.string(),
          email: z.string()
        })
      }
    };
    
    const apiFetch = createFetch(api, 'https://api.example.com');
    
    // Type-safe request with validation
    const user = await apiFetch('/users/:id', {
      params: { id: 123 },
      query: { fields: 'name,email' }
    });
    // user is typed as { id: number; name: string; email: string }
    ```
  </Tab>
  <Tab value="Without afetch">
    ```typescript
    // Define types manually
    interface User {
      id: number;
      name: string;
      email: string;
    }
    
    // Build URL manually
    const url = `https://api.example.com/users/${id}?fields=${fields}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Manual validation required
    if (typeof data.id !== 'number' || 
        typeof data.name !== 'string' || 
        typeof data.email !== 'string') {
      throw new Error('Invalid response');
    }
    
    const user: User = data;
    // No compile-time guarantees that data matches User type
    ```
  </Tab>
</Tabs>
