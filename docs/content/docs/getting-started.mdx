---
title: Getting Started
description: Quick start guide to install and use what-the-fetch in your JavaScript or TypeScript project
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Cards, Card } from 'fumadocs-ui/components/card';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';

## Installation

Install what-the-fetch using your preferred package manager:

<Tabs items={['bun', 'pnpm', 'yarn', 'npm', 'jsr']}>
  <Tab value="bun">
    ```bash
    bun add what-the-fetch
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm add what-the-fetch
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn add what-the-fetch
    ```
  </Tab>
  <Tab value="npm">
    ```bash
    npm install what-the-fetch
    ```
  </Tab>
  <Tab value="jsr">
    ```bash
    deno add jsr:@hckhanh/what-the-fetch
    ```
  </Tab>
</Tabs>

You'll also need a schema validation library that implements Standard Schema:

<Tabs items={['Zod', 'Valibot', 'ArkType']}>
  <Tab value="Zod">
    ```bash
    npm install zod
    ```
  </Tab>
  <Tab value="Valibot">
    ```bash
    npm install valibot
    ```
  </Tab>
  <Tab value="ArkType">
    ```bash
    npm install arktype
    ```
  </Tab>
</Tabs>

<Callout title="TypeScript Support" type="info">
  what-the-fetch is written in TypeScript and includes type definitions out of the
  box. No need to install separate `@types` packages!
</Callout>

## Basic Usage

### Importing

```typescript
import { createFetch } from 'what-the-fetch';
import { z } from 'zod'; // or your preferred schema library
```

### Quick Examples

Here are some common use cases to get you started:

#### Simple GET Request

Define a schema and make a type-safe request:

```typescript
import { createFetch } from 'what-the-fetch';
import { z } from 'zod';

const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const user = await apiFetch('/users/:id', {
  params: { id: 123 }
});
// user is typed as { id: number; name: string; email: string }
```

#### With Query Parameters

Add query parameters to your request:

```typescript
const api = {
  '/users': {
    query: z.object({
      limit: z.number().optional(),
      offset: z.number().optional(),
      sort: z.string().optional()
    }),
    response: z.array(z.object({
      id: z.number(),
      name: z.string()
    }))
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const users = await apiFetch('/users', {
  query: { limit: 10, offset: 20, sort: 'name' }
});
// users is typed as Array<{ id: number; name: string }>
```

#### POST Request with Body

Send data in the request body:

```typescript
const api = {
  '/users': {
    body: z.object({
      name: z.string(),
      email: z.string().email()
    }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const newUser = await apiFetch('/users', {
  body: {
    name: 'John Doe',
    email: 'john@example.com'
  }
});
// newUser is typed as { id: number; name: string; email: string }
```

## Step-by-Step Tutorial

Let's build a complete type-safe API client using what-the-fetch:

<Steps>
  <Step>
    ### Define Your API Schema
    
    Start by defining schemas for all your API endpoints:
    
    ```typescript
    import { z } from 'zod';
    
    const api = {
      '/posts': {
        // GET /posts - List posts with filters
        query: z.object({
          page: z.number().optional(),
          limit: z.number().optional(),
          tag: z.string().optional()
        }),
        response: z.array(z.object({
          id: z.number(),
          title: z.string(),
          excerpt: z.string()
        }))
      },
      '/posts/:id': {
        // GET /posts/:id - Get post by ID
        params: z.object({ id: z.number() }),
        response: z.object({
          id: z.number(),
          title: z.string(),
          content: z.string(),
          author: z.string()
        })
      },
      '/posts/create': {
        // POST /posts/create - Create new post
        body: z.object({
          title: z.string(),
          content: z.string()
        }),
        response: z.object({
          id: z.number(),
          title: z.string(),
          content: z.string()
        })
      }
    } as const;
    ```
  </Step>
  
  <Step>
    ### Create the Fetch Function
    
    Use createFetch to build your typed API client:
    
    ```typescript
    import { createFetch } from 'what-the-fetch';
    
    const apiFetch = createFetch(api, 'https://api.blog.com');
    ```
  </Step>
  
  <Step>
    ### Make Type-Safe Requests
    
    Now you can make fully typed requests with autocomplete:
    
    ```typescript
    // Fetch posts with query parameters
    const posts = await apiFetch('/posts', {
      query: { page: 2, limit: 20, tag: 'javascript' }
    });
    // posts is typed as Array<{ id: number; title: string; excerpt: string }>
    
    // Fetch a single post
    const post = await apiFetch('/posts/:id', {
      params: { id: 42 }
    });
    // post is typed as { id: number; title: string; content: string; author: string }
    ```
  </Step>
  
  <Step>
    ### Add Custom Headers (Optional)
    
    You can pass custom headers using the third parameter:
    
    ```typescript
    const post = await apiFetch(
      '/posts/:id',
      { params: { id: 42 } },
      {
        headers: {
          'Authorization': 'Bearer your-api-key',
          'X-Custom-Header': 'value'
        }
      }
    );
    ```
  </Step>
</Steps>

## Common Patterns

### Using Different Schema Libraries

what-the-fetch works with any Standard Schema implementation:

<Tabs items={['Zod', 'Valibot', 'ArkType']}>
  <Tab value="Zod">
    ```typescript
    import { createFetch } from 'what-the-fetch';
    import { z } from 'zod';
    
    const api = {
      '/users/:id': {
        params: z.object({ id: z.number() }),
        response: z.object({ id: z.number(), name: z.string() })
      }
    };
    
    const apiFetch = createFetch(api, 'https://api.example.com');
    ```
  </Tab>
  <Tab value="Valibot">
    ```typescript
    import { createFetch } from 'what-the-fetch';
    import * as v from 'valibot';
    
    const api = {
      '/users/:id': {
        params: v.object({ id: v.number() }),
        response: v.object({ id: v.number(), name: v.string() })
      }
    };
    
    const apiFetch = createFetch(api, 'https://api.example.com');
    ```
  </Tab>
  <Tab value="ArkType">
    ```typescript
    import { createFetch } from 'what-the-fetch';
    import { type } from 'arktype';
    
    const api = {
      '/users/:id': {
        params: type({ id: 'number' }),
        response: type({ id: 'number', name: 'string' })
      }
    };
    
    const apiFetch = createFetch(api, 'https://api.example.com');
    ```
  </Tab>
</Tabs>

### Combining Path and Query Parameters

Mix path parameters with query parameters:

```typescript
const api = {
  '/users/:id/posts': {
    params: z.object({ id: z.number() }),
    query: z.object({
      limit: z.number().optional(),
      published: z.boolean().optional()
    }),
    response: z.array(z.object({
      id: z.number(),
      title: z.string()
    }))
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

const posts = await apiFetch('/users/:id/posts', {
  params: { id: 123 },
  query: { limit: 10, published: true }
});
// URL: https://api.example.com/users/123/posts?limit=10&published=true
```

### Custom Request Configuration

Pass additional fetch options as the third parameter:

```typescript
const user = await apiFetch(
  '/users/:id',
  { params: { id: 123 } },
  {
    headers: {
      'Authorization': 'Bearer token',
      'X-API-Key': 'your-key'
    },
    cache: 'no-cache',
    signal: abortController.signal
  }
);
```

### Reusing the Same Fetch Function

Create one fetch function and reuse it throughout your application:

```typescript
// api.ts
export const apiFetch = createFetch(api, 'https://api.example.com');

// users.ts
import { apiFetch } from './api';

const user = await apiFetch('/users/:id', { params: { id: 123 } });

// posts.ts
import { apiFetch } from './api';

const posts = await apiFetch('/posts', { query: { limit: 10 } });
```

## Schema Validation Benefits

what-the-fetch validates both requests and responses automatically:

```typescript
const api = {
  '/users': {
    body: z.object({
      name: z.string().min(3),
      email: z.string().email()
    }),
    response: z.object({
      id: z.number(),
      name: z.string(),
      email: z.string()
    })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

// ✅ Valid request
const user = await apiFetch('/users', {
  body: {
    name: 'John Doe',
    email: 'john@example.com'
  }
});

// ❌ This would fail at runtime with validation error
try {
  await apiFetch('/users', {
    body: {
      name: 'Jo', // Too short
      email: 'invalid-email' // Invalid format
    }
  });
} catch (error) {
  console.error('Validation failed:', error);
}
```

## Error Handling

what-the-fetch provides clear error messages for both validation and HTTP errors:

```typescript
const api = {
  '/users/:id': {
    params: z.object({ id: z.number() }),
    response: z.object({ id: z.number(), name: z.string() })
  }
};

const apiFetch = createFetch(api, 'https://api.example.com');

try {
  const user = await apiFetch('/users/:id', { params: { id: 123 } });
} catch (error) {
  // Could be:
  // 1. HTTP error (status !== 2xx)
  // 2. Schema validation error
  // 3. Network error
  console.error('Request failed:', error);
}
```

### Handling HTTP Errors

what-the-fetch automatically throws on non-2xx status codes:

```typescript
try {
  const user = await apiFetch('/users/:id', { params: { id: 999 } });
} catch (error) {
  if (error.message.includes('HTTP error')) {
    console.error('Request failed with status:', error);
    // Handle 404, 500, etc.
  }
}
```

### Handling Validation Errors

Schema validation errors are thrown when response doesn't match schema:

```typescript
try {
  const user = await apiFetch('/users/:id', { params: { id: 123 } });
} catch (error) {
  // Validation error if response doesn't match schema
  console.error('Invalid response:', error);
}
```

<Callout title="Type Safety" type="success">
  With TypeScript, most parameter errors are caught at compile time, preventing
  runtime errors before they happen!
</Callout>
